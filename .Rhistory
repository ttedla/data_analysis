alphabet
# extract 18th character in string
substr(alphabet, start = 18, stop = 18)
# extract 18-24th characters in string
substr(alphabet, start = 18, stop = 24)
# replace 19-24th characters with `R`
substr(alphabet, start = 18, stop = 24) <- "RRRRRR"
alphabet
alphabet <- paste (LETTERS, collapse = "")
alphabet
# extract 18th through last character
substring(alphabet, first = 18)
# recursive extraction; specify start position only
substring(alphabet, first = 18:24)
substring(alphabet, first = 1:5, last = 3:7)
strsplit(z, split = " ")
a <- "Alabama-Alaska-Arizona-Arkansas-California"
strsplit(a, split = "-")
unlist(strsplit(a, split = "-"))
library(stringr)
# same as paste0 ()
str_c ("Learning", "to", "use", "the", "stringr", "package")
# -------------------------------------------------------------------------
# same as paste ()
str_c ("Learning", "to", "use", "the", "stringr", "package", sep = " ")
# allows recycling
str_c (letters, " is for", "...")
# some text with NA
text = c ("Learning", "to", NA, "use", "the", NA, "stringr", "package")
# compare ` str_length ()` with ` nchar ()`
nchar(text)
str_length(text)
x <- "Learning to use the stringr package"
x
str_sub(x, start = 1, end = 5)
str_sub(x, start = 1, end = 15)
# or #
str_sub(x, end = 15)
############## from the 17 to the end #
str_sub(x, start = 17)
str_sub(x, start = c(1,17), end = c(15, 35))
# # using negative indices for start/end points from end of string
str_sub(x, -1)
# # using negative indices for start/end points from end of string
str_sub(x, start=-1)
str_sub(x, start = -19)
str_sub(x, end = -19)
str_sub(x, end = -21)
# -------------------------------------------------------------------------
x
str_sub(x, start = -19)
str_sub(x, end = -21)
library(stringr)
str_dup("beer", 3)
str_dup("beer", 1:3)
states_i_luv <- state.name[ c (6, 23, 34, 35)]
states_i_luv
str_dup(states_i_luv, 2)
str_dup(states_i_luv, times=2)
text <- c ("Text ", " with", " whitespace ", " on", "both ", " sides ")
text
# -------------------------------------------------------------------------
# trim whitespace from the right side
str_trim(text, side = "right")
# trim from the left side
str_trim(text, side = "left")
# trim from both sides
str_trim(text, side = "both")
str_pad("beer", width = 10, side = "left")
str_pad("beer", width = 10, side = "both")
str_pad("beer", width = 10, side = "right", pad = "!")
set_1 <- c ("lagunitas", "bells", "dogfi sh", "summit", "odell")
set_2 <- c ("sierra", "bells", "harpoon", "lagunitas", "founders")
union(set_1, set_2)
intersect(set_1, set_2)
# returns elements in set_1 not in set_2
setdiff(set_1, set_2)
set_1 <- c ("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c ("sierra", "bells", "harpoon", "lagunitas", "founders")
# returns elements in set_1 not in set_2
setdiff(set_1, set_2)
# returns elements in set_2 not in set_1
setdiff(set_2, set_1)
set_3 <- c ("woody", "buzz", "rex")
set_4 <- c ("woody", "andy", "buzz")
set_5 <- c ("andy", "buzz", "woody")
# To test if two vectors contain the same elements regardless of order use
# setequal() :
setequal(set_3, set_4)
setequal(set_4, set_5)
set_6 <- c ("woody", "andy", "buzz")
set_7 <- c ("andy", "buzz", "woody")
set_8 <- c ("woody", "andy", "buzz")
identical(set_6, set_7)
identical(set_6, set_88888888888888)
identical(set_6, set_8)
good <- "andy"
bad <- "sid"
set_1 <- c ("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c ("sierra", "bells", "harpoon", "lagunitas", "founders")
set_3 <- c ("woody", "buzz", "rex")
set_4 <- c ("woody", "andy", "buzz")
set_5 <- c ("andy", "buzz", "woody")
set_6 <- c ("woody", "andy", "buzz")
set_7 <- c ("andy", "buzz", "woody")
set_8 <- c ("woody", "andy", "buzz")
# -------------------------------------------------------------------------
is.element(good, set_8)
good %in% set_8
bad %in% set_8
set_1 <- c ("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c ("sierra", "bells", "harpoon", "lagunitas", "founders")
set_3 <- c ("woody", "buzz", "rex")
set_4 <- c ("woody", "andy", "buzz")
set_5 <- c ("andy", "buzz", "woody")
set_6 <- c ("woody", "andy", "buzz")
set_7 <- c ("andy", "buzz", "woody")
set_8 <- c ("woody", "andy", "buzz")
# -------------------------------------------------------------------------
sort(set_8)
sort(set_8, decreasing = TRUE)
?sub
sub(pattern = "\\$", replacement = "\\!", "I Love You R!")
sub(pattern = "\\$", replacement = "\\!", "I Love You R$")
text= "My daughter has a ^ with almost every meal!"
text
sub(pattern = "\\^", replacement = "\\#", text)
sub(pattern = "\\^", replacement = "carrot", text)
text = "I\\need\\space"
text
sub(pattern = "\\\\", replacement = "\\ ", text)
sub(pattern = "\\\\", replacement = " ", text)
sub(pattern = "\\\\", replacement = " ", text)
gsub(pattern = "\\\\", replacement = " ", text)
my_text= "I'm working in RStudio v.0.99.484"
# -------------------------------------------------------------------------
my_text= "I'm working in RStudio v.0.99.484"
# -------------------------------------------------------------------------
gsub(pattern = "\d", replacement = "_", my_text)
# -------------------------------------------------------------------------
gsub(pattern = "\d", replacement = "\_", my_text)
# -------------------------------------------------------------------------
gsub(pattern = "\\d", replacement = "_", my_text)
gsub(pattern = "\\D", replacement = "_", my_text)
gsub(pattern = "\\s", replacement = "_", my_text)
gsub(pattern = "\\w", replacement = "_", my_text)
x <- c ("RStudio", "v.0.99.484", "2015", "09-22-2015", "grep vs. grepl")
x
# -------------------------------------------------------------------------
# find any strings with numeric values between 0-9
grep(pattern = [0-9], x)
# -------------------------------------------------------------------------
# find any strings with numeric values between 0-9
grep(pattern = "[0-9]", x)
# -------------------------------------------------------------------------
# find any strings with numeric values between 0-9
grep(pattern = "[0-9]", x, value = TRUE)
x[2]
x[3]
x[4]
# to get the index only
grep(pattern = "[0-9]", x)
grep(pattern = "[6-9]", x, value = TRUE)
# find any strings with the character R or r
grep(pattern = "[Rr]", x, value = TRUE)
# find any strings that have non-alphanumeric characters
grep(pattern = "^[0-9a-zA-Z]", x, value = TRUE)
x
# find any strings that have non-alphanumeric characters
grep(pattern = "[^0-9a-zA-Z]", x, value = TRUE)
my_text <- "I like beer! #beer, @wheres_my_beer, I like R (v3.2.2) #rrrrrrr2015"
gsub(pattern = "[[:blank:]]", replacement = "", my_text )
gsub(pattern = "[[:punct:]]", replacement = " ", x)
gsub(pattern = "[[:punct:]]", replacement = " ", my_text)
# remove alphanumeric characters
gsub(pattern = "[[:alnum:]]", replacement = "", my_text)
states <- state.name
abbreviate(states)
abbreviate(states, minlength = 2)
grep(pattern = "z+", states, value = TRUE)
# match states with two s
grep(pattern = "s{2}", states, value = TRUE)
#match states with one or two s
grep(pattern = "s{1,2}", states, value = TRUE)
# use the built in data set state.division
head(as.character(state.division))
# -------------------------------------------------------------------------
grep(pattern = "North", state.division)
# to see the values use value=True
grep(pattern = "North", state.division, value = TRUE)
grep("North | South", state.division, invert = TRUE)
grepl("North | South", state.division)
# wrap in sum() to get the count of matches
sum(grepl("North | South", state.division))
#To find exactly where the pattern exists in a string use regexpr () :
x <- c ("v.111", "0v.11", "00v.1", "000v.", "00000")
regexpr("v.", x)
# To replace the fi rst matching occurrence of a pattern use sub() :
new <- c ("New York", "new new York", "New New New York")
new
# Default is case sensitive - replace "New" with "Old"
sub(pattern = "New", replacement = "Old", new)
# use 'ignore.case = TRUE' to disable case sensitivity
sub(pattern = "New", replacement = "Old", new, ignore.case = TRUE)
new
# Default is case sensitive - replace "New" with "Old"
sub(pattern = "New", replacement = "Old", new)
# use 'ignore.case = TRUE' to disable case sensitivity
sub(pattern = "New", replacement = "Old", new, ignore.case = TRUE)
gsub(pattern = "New", replacement = "Old", new)
gsub(pattern = "New", replacement = "Old", new, ignore.case = TRUE)
x <- paste(state.name[1:10], collapse = " ")
x
# output will be a space separated list
strsplit(x, " ")
# output will be a space separated list
length(strsplit(x, " "))
# load package
library (stringr)
# use the built in data set 'state.name'
head (state.name)
str_detect(state.name, pattern = "New")
# count the total matches by wrapping with sum
sum(str_detect(state.name, pattern = "New"))
library(stringr)
x <- c ("abcd", "a22bc1d", "ab3453cd46", "a1bc44d")
# locate 1st sequence of 1 or more consecutive numbers
str_locate(x, pattern = [0-9+])
# locate 1st sequence of 1 or more consecutive numbers
str_locate(x, pattern = [:0-9:+])
# locate 1st sequence of 1 or more consecutive numbers
str_locate(x, pattern = [[:0-9:+]])
# locate 1st sequence of 1 or more consecutive numbers
str_locate(x, pattern = "0-9")
# locate 1st sequence of 1 or more consecutive numbers
str_locate(x, pattern = "[0-9]+")
str_locate_all(x, pattern = "[0-9]+")
library(stringr)
# -------------------------------------------------------------------------
y <- c ("I use R #useR2014", "I use R and love R #useR2015", "Beer")
# To extract elements containing "R"
str_extract(y, pattern = "R")
str_extract_all(y, pattern = "R")
str_extract_all(y, pattern = "[[:punct:]]*[a-zA-Z0-9]* R[a-zA-Z0-9]*")
str_extract_all(y, pattern = "[[:punct:]]*[a-zA-Z0-9]*R[a-zA-Z0-9]*")
# -------------------------------------------------------------------------
# [[:punct:]]*  ==> matchs zero or more occurance of punctuation
# [a-zA-Z0-9]*  ==> followed by occurance of zero or more alphanumeric
# R[a-zA-Z0-9]* ==> followed "R" followed by zero or more alphanumeric
# e.g. *#Aa0Ramp123 can be extracted by this exract
z <- c("*#Aa0Ramp123")
str_extract_all(z, pattern = "[[:punct:]]*[a-zA-Z0-9]*R[a-zA-Z0-9]*")
library(stringr)
cities <- c ("New York", "new new York", "New New New York")
cities
sub(pattern = "New", replacement = "Old", cities)
# -------------------------------------------------------------------------
# replacing first occurance using sub ignore.case=TRUE
sub(pattern = "New", replacement = "Old", ignore.case = TRUE, cities)
# -------------------------------------------------------------------------
# replacing all occurance using gsub
gsub(pattern = "New", replacement = "Old", ignore.case = TRUE, cities)
# replacing using the stringr function str_replace
str_replace(cities, pattern = "New", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace(cities, pattern = "[N]*[n]*ew", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace("Nnew", pattern = "[N]*[n]*ew", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace("new", pattern = "[N]*[n]*ew", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace("New", pattern = "[N]*[n]*ew", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace("NNNNNNew", pattern = "[N]*[n]*ew", replacement = "Old")
# to deal with case sensitivities use Regex syntax in the 'pattern' argument
str_replace(cities, pattern = "[N]*[n]*ew", replacement = "Old")
# To extract all occurrences of a pattern in a character vector
# use str_replace_all() . This function is a wrapper for gsub () .
str_replace_all(cities, pattern = "[N]*[n]ew", replacement = "Old")
# To extract all occurrences of a pattern in a character vector
# use str_replace_all() . This function is a wrapper for gsub () .
str_replace_all(cities, pattern = "[N]*[n]*ew", replacement = "Old")
library(stringr)
z <- "The day after I will take a break and drink a beer."
# split using strsplit (baseR)
strsplit(z, split = " ")
a <- "Alabama-Alaska-Arizona-Arkansas-California"
# split using str_split() stringr
str_split(z, pattern = " ")
# using baseR
strsplit(a, split = "-")
str_split(a, pattern = "-")
strsplit(a, split = "-")
unlist(strsplit(a, split = "-"))
# str_split
ulist(str_split(a, pattern = "-"))
# str_split
unlist(str_split(a, pattern = "-"))
# Factor objects can be created with the factor () function:
# create a factor string
gender <- factor( c("male", "female", "female", "male", "female"))
gender
# inspect to see if it is a factor class
class(gender)
# show that factors are just built on top of integers
typeof(gender)
# See the underlying representation of factor
unclass(gender)
# what are the factor levels?
levels(gender)
# show summary of counts
summary(gender)
table(gender)
group <- c ("Group1", "Group2", "Group2", "Group1", "Group1")
str(group)
# -------------------------------------------------------------------------
# convert from characters to factors
as.factor(group)
# when not specified the default puts order as alphabetical
gender <- factor ( c ("male", "female", "female", "male", "female"))
gender
# -------------------------------------------------------------------------
# specifying order
gender <- factor(c("male", "female", "female", "male","female"),
levels = c("male", "female"))
gender
ses <- c ("low", "middle", "low", "low", "low", "low", "middle", "low",
"middle", "middle", "middle", "middle", "middle", "high", "high",
"low", "middle","middle", "low", "high")
ses
class(ses)
ses <- factor(ses, levels = c("low", "middle", "high"), ordered = TRUE)
class(ses)
ses
# you can also reverse the order of levels if desired
ses <- (ses, levels=rev(levels(ses)))
# you can also reverse the order of levels if desired
ses <- (ses, levels=rev(levels(ses)))
# you can also reverse the order of levels if desired
factor(ses, levels=rev(levels(ses)))
ses <- c ("low", "middle", "low", "low", "low", "low", "middle", "low", "middle",
"middle", "middle", "middle", "middle", "high", "high", "low", "middle",
"middle", "low", "high")
ses
ses <- factor(ses, levels = c("low", "middle", "high"), ordered = TRUE)
ses
plyr:: revalue (ses, c ("low" = "small", "middle" = "medium", "high" = "large"))
ses <- c ("low", "middle", "low", "low", "low", "low", "middle", "low", "middle",
"middle", "middle", "middle", "middle", "high", "high", "low", "middle",
"middle", "low", "high")
ses <- factor(ses, levels = c("low", "middle", "high"), ordered = TRUE)
ses <- plyr::revalue(ses, replace = c("low" = "small", "middle" = "medium",
"high", "large"))
ses <- plyr::revalue(ses, replace = c("low" = "small", "middle" = "medium",
"high"="large"))
ses <- plyr::revalue(ses, replace = c("low" = "small", "middle" = "medium", "high"="large"))
ses <- plyr::revalue(ses, c("low" = "small", "middle" = "medium", "high"="large"))
plyr::revalue(ses, c("low" = "small", "middle" = "medium", "high"="large"))
ses1 <- plyr::revalue(ses, c("low" = "small", "middle" = "medium", "high"="large"))
ses1
ses
ses <- c ("low", "middle", "low", "low", "low", "low", "middle", "low", "middle",
"middle", "middle", "middle", "middle", "high", "high", "low", "middle",
"middle", "low", "high")
ses <- factor(ses, levels = c("low", "middle", "high"), ordered = TRUE)
ses1 <- plyr::revalue(ses, c("low" = "small", "middle" = "medium", "high"="large"))
ses1
ses
# -------------------------------------------------------------------------
summary(ses)
summary(ses1)
# When you want to drop unused factor levels , use droplevels () :
ses2 <- ses1[ses1 != "middle"]
ses2
summary(ses2)
# When you want to drop unused factor levels , use droplevels () :
ses2 <- ses[ses != "middle"]
ses2
summary(ses2)
# # you can drop that level if desired
droplevels(ses2)
summary(ses2)
df <- data.frame(Year = as.factor(c(rep(2015, 3), rep(2016, 3), rep(2017,3))),
Tax = as.factor(c(rep(c("A", "B", "C"), 3))),
Depth = as.factor(c(10, 30, 50, 20,30,50,10,30,40)),
values= c(0.5, 0.25, 0.25, 0.1, 0.4, 0.5, 0.2, 0.6, 0.2))
library(ggplot2)
ggplot(df, aes(Depth, values, fill=Tax)) + geom_bar(stat="identity")+
facet_wrap(~Year, scale="free") +
coord_flip()
ggplot(df, aes(Depth, values, fill=Tax)) + geom_bar(stat="identity")+
facet_wrap(~Year) +
coord_flip()
setwd("~/data_analysis/")
my_data <- read.csv("./data/my_data.csv")
str(my_data)
my_data <- read.csv("./data/my_data.csv", stringsAsFactors = FALSE)
str(my_data)
# provides same results as read.csv above
my_data <- read.table("./data/my_data.csv", sep = ",", header = TRUE, stringsAsFactors = FALSE)
str(my_data)
my_data <- read.table("./data/my_data.csv",
sep = ",",
stringsAsFactors = FALSE,
col.names = c("Var 1", "Var 2", "Var 3"),
row.names = c("Row 1", "Row 2", "Row 3"))
View(my_data)
my_data <- read.table("./data/my_data.csv", header = TRUE,
sep = ",",
stringsAsFactors = FALSE,
col.names = c("Var 1", "Var 2", "Var 3"),
row.names = c("Row 1", "Row 2", "Row 3"))
str(my_data)
a=c("A","A","A","A","A","B","B","B","B","B")
b=c(1,2,3,4,5,11,12,13214634,14,15432)
df=data.frame(a,b)
df
split(df$a, df$b)
set_classes <- read.table("./data/my_data.csv",
header = TRUE,
sep = ",",
colClasses = c("numeric", "character", "character"))
str(set_classes)
my_data <- read.table("./data/my_data.csv", sep = ",",
header = TRUE, nrows = 2)
my_data
library (readr)
my_data_r <- read_csv("./data/my_data.csv")
str(my_data_r)
distance <- c(0.8, 3.1, 2.8, 4.0) #miles
time <- c(10, 30, 40, 50) #minutes
speed <- distance/time
speed
round(speed, 10)
round(speed, 20)
distance <- c(0.8, 3.1, 2.8, 4.0) #miles
time <- c(10, 30, 40, 50) #minutes
time<-time/60
speed <- distance/time
speed
round(speed, 20)
round(speed, 3)
speed <- round((distance/time), 10)
speed
time
distance
speed <- (distance/time)
speed
signif(speed)
signif(speed, 3)
signif(speed, 4)
speed <- signif(distance/time)
speed
speed <- signif((distance/time), 4)
speed
format(speed, digits=3)
format(speed, digits=4)
format(x, digits=2, nsmall=3)
format(speed, digits=2, nsmall=3)
?format
format(speed, trim = F)
time
distance
4.0/0.8333333
format(4.0/0.8333333, trim = F)
format(4.0/0.8333333, trim = F, nsmall = 5)
40/8.3
40/8.3333
distance <- c(0.8, 3.1, 2.8, 4.0) #miles
time <- c(10, 30, 40, 50) #minutes
time<-time/60
distance
time
4.0/0.8333333
format(4.0/0.8333333, nsmall = 9)
format(distance[4]/time[4], nsmall = 9)
50/60
4*60
24/5
typeof(format(4.0/0.8333333, nsmall = 9))
class(format(4.0/0.8333333, nsmall = 9))
format(4.0/0.8333333, nsmall = 9)
# specify the column class using col_types
read_csv ("./data/my_data.csv", col_types = list(col_double (),
col_character (),
col_character ()))
# we can also specify column classes with a string
# in this example d = double, _ skips column, c = character
read_csv ("./data/my_data.csv", col_types = "d_c")
read_csv("./data/my_data.csv", col_names = c("Var 1", "Var 2", "Var 3"), skip = 1)
read_csv("./data/my_data.csv", col_names = c("Var 1", "Var 2", "Var 3"))
read_csv("./data/my_data.csv", col_names = c("Var 1", "Var 2", "Var 3"), skip = 1)
# to set the maximum number of rows to read
read_csv("./data/my_data.csv", n_max = 2)
seq<-c("A","A","A","B","B","B","B")
rank<-c(1,2,3,1,2,3,4)
match<-c("y","n","y","n","n","y","y")
df<- as.data.frame(cbind(seq,rank,match))
df
df$choose <- ifelse(['rank'==1 & 'match'=='y']=T,F)
df$choose <- ifelse([df$rank==1 & df$match=='y']=T,F)
df$choose <- ifelse(df$rank==1 & df$match=='y'=T,F)
df$choose <- ifelse((df$rank==1 & df$match=='y'),T,F)
head(df)
apply(df,1,match,df$match='Y')
apply(df,1,match,df$match=='Y')
sapply(df,1,match,df$match=='Y')
lapply(df,1,match,df$match=='Y')
lapply(df,2,match,df$match=='Y')
apply(df,2,match,df$match=='Y')
library(flexdashboard)
library(flexdashboard)
